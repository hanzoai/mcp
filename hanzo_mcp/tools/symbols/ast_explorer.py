"""AST explorer for navigating and visualizing code structure using tree-sitter.

This module provides functionality for exploring and visualizing Abstract Syntax Trees
generated by tree-sitter, helping to understand code structure and relationships.
"""

import os
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Union, Any

from hanzo_mcp.tools.symbols.tree_sitter_manager import TreeSitterManager

logger = logging.getLogger(__name__)


class ASTExplorer:
    """Explores and visualizes Abstract Syntax Trees using tree-sitter."""

    def __init__(self, tree_sitter_manager: TreeSitterManager):
        """Initialize the ASTExplorer.
        
        Args:
            tree_sitter_manager: TreeSitterManager instance for parsing
        """
        self.tree_sitter_manager = tree_sitter_manager
    
    def get_ast(self, file_path: str, simplified: bool = False) -> Optional[Dict[str, Any]]:
        """Get the AST for a file.
        
        Args:
            file_path: Path to the file
            simplified: Whether to return a simplified AST
            
        Returns:
            Dictionary representation of the AST or None if parsing failed
        """
        # Parse the file
        tree = self.tree_sitter_manager.parse_file(file_path)
        if not tree:
            logger.error(f"Failed to parse file: {file_path}")
            return None
        
        # Read the file content
        with open(file_path, "rb") as f:
            source_code = f.read()
        
        # Convert tree to dictionary
        root_node = tree.root_node
        if simplified:
            return self._node_to_simplified_dict(root_node, source_code)
        else:
            return self._node_to_dict(root_node, source_code)
    
    def get_ast_for_code(self, source_code: str, language: str, simplified: bool = False) -> Optional[Dict[str, Any]]:
        """Get the AST for a string of source code.
        
        Args:
            source_code: Source code string
            language: Language name
            simplified: Whether to return a simplified AST
            
        Returns:
            Dictionary representation of the AST or None if parsing failed
        """
        # Parse the code
        tree = self.tree_sitter_manager.parse_code(source_code, language)
        if not tree:
            logger.error(f"Failed to parse {language} code")
            return None
        
        # Convert string to bytes if needed
        if isinstance(source_code, str):
            source_bytes = source_code.encode("utf-8")
        else:
            source_bytes = source_code
        
        # Convert tree to dictionary
        root_node = tree.root_node
        if simplified:
            return self._node_to_simplified_dict(root_node, source_bytes)
        else:
            return self._node_to_dict(root_node, source_bytes)
    
    def query_ast(self, file_path: str, query_string: str) -> List[Dict[str, Any]]:
        """Query the AST using a tree-sitter query.
        
        Args:
            file_path: Path to the file
            query_string: Tree-sitter query string
            
        Returns:
            List of matches
        """
        # Detect language
        language_name = self.tree_sitter_manager.detect_language(file_path)
        if not language_name:
            logger.warning(f"Unsupported file type: {file_path}")
            return []
        
        # Read the file
        try:
            with open(file_path, "rb") as f:
                source_code = f.read()
        except Exception as e:
            logger.error(f"Error reading file {file_path}: {e}")
            return []
        
        # Execute query
        return self.tree_sitter_manager.execute_query(language_name, query_string, source_code)
    
    def query_code(self, source_code: str, language: str, query_string: str) -> List[Dict[str, Any]]:
        """Query a string of source code using a tree-sitter query.
        
        Args:
            source_code: Source code string
            language: Language name
            query_string: Tree-sitter query string
            
        Returns:
            List of matches
        """
        # Execute query
        return self.tree_sitter_manager.execute_query(language, query_string, source_code)
    
    def get_node_by_position(self, file_path: str, line: int, column: int) -> Optional[Dict[str, Any]]:
        """Get the AST node at a specific position in a file.
        
        Args:
            file_path: Path to the file
            line: Line number (1-indexed)
            column: Column number (1-indexed)
            
        Returns:
            Dictionary representation of the node or None if not found
        """
        # Parse the file
        tree = self.tree_sitter_manager.parse_file(file_path)
        if not tree:
            logger.error(f"Failed to parse file: {file_path}")
            return None
        
        # Read the file content
        with open(file_path, "rb") as f:
            source_code = f.read()
        
        # Adjust to 0-indexed
        line -= 1
        column -= 1
        
        # Find node at position
        point = (line, column)
        node = tree.root_node.descendant_for_point_range(point, point)
        
        if node:
            return self._node_to_dict(node, source_code)
        
        return None
    
    def extract_syntax_structure(self, file_path: str) -> Dict[str, Any]:
        """Extract a high-level syntax structure from a file.
        
        Args:
            file_path: Path to the file
            
        Returns:
            Dictionary with high-level syntax structure
        """
        # Detect language
        language_name = self.tree_sitter_manager.detect_language(file_path)
        if not language_name:
            logger.warning(f"Unsupported file type: {file_path}")
            return {"error": f"Unsupported file type: {file_path}"}
        
        # Parse the file
        tree = self.tree_sitter_manager.parse_file(file_path)
        if not tree:
            logger.error(f"Failed to parse file: {file_path}")
            return {"error": f"Failed to parse file: {file_path}"}
        
        # Read the file content
        with open(file_path, "rb") as f:
            source_code = f.read()
        
        # Extract structure based on language
        if language_name == "python":
            return self._extract_python_structure(tree, source_code)
        elif language_name in ["javascript", "typescript"]:
            return self._extract_js_ts_structure(tree, source_code, language_name)
        elif language_name in ["java", "c", "cpp", "c_sharp"]:
            return self._extract_c_family_structure(tree, source_code, language_name)
        else:
            # Generic extraction
            return self._extract_generic_structure(tree, source_code)
    
    def visualize_ast(self, file_path: str, output_format: str = "text") -> str:
        """Visualize the AST of a file.
        
        Args:
            file_path: Path to the file
            output_format: Output format ("text", "json", "html")
            
        Returns:
            Visualization of the AST in the specified format
        """
        # Parse the file
        tree = self.tree_sitter_manager.parse_file(file_path)
        if not tree:
            logger.error(f"Failed to parse file: {file_path}")
            return f"Error: Failed to parse file: {file_path}"
        
        # Read the file content
        with open(file_path, "rb") as f:
            source_code = f.read()
        
        # Generate visualization
        if output_format == "json":
            ast_dict = self._node_to_dict(tree.root_node, source_code)
            return json.dumps(ast_dict, indent=2)
        elif output_format == "html":
            return self._generate_html_visualization(tree.root_node, source_code, file_path)
        else:  # Default to text
            return self._generate_text_visualization(tree.root_node, source_code)
    
    def _node_to_dict(self, node: Any, source_code: bytes) -> Dict[str, Any]:
        """Convert a node to a dictionary representation.
        
        Args:
            node: Tree-sitter node
            source_code: Source code as bytes
            
        Returns:
            Dictionary representation of the node
        """
        result = {
            "type": node.type,
            "text": self.tree_sitter_manager.get_node_text(node, source_code),
            "start_point": {
                "row": node.start_point[0] + 1,  # 1-indexed
                "column": node.start_point[1] + 1,  # 1-indexed
            },
            "end_point": {
                "row": node.end_point[0] + 1,  # 1-indexed
                "column": node.end_point[1] + 1,  # 1-indexed
            },
            "children": [self._node_to_dict(child, source_code) for child in node.children]
        }
        
        # Add named children if different from children
        if len(node.named_children) != len(node.children):
            result["named_children"] = [
                self._node_to_dict(child, source_code) for child in node.named_children
            ]
        
        # Add field names if available
        field_names = {}
        for field_name in node.field_names():
            field_node = node.field_dict.get(field_name)
            if field_node:
                if isinstance(field_node, list):
                    field_names[field_name] = [
                        self._node_to_dict(n, source_code) for n in field_node
                    ]
                else:
                    field_names[field_name] = self._node_to_dict(field_node, source_code)
        
        if field_names:
            result["fields"] = field_names
        
        return result
    
    def _node_to_simplified_dict(self, node: Any, source_code: bytes) -> Dict[str, Any]:
        """Convert a node to a simplified dictionary representation.
        
        Args:
            node: Tree-sitter node
            source_code: Source code as bytes
            
        Returns:
            Simplified dictionary representation of the node
        """
        result = {
            "type": node.type,
            "location": f"{node.start_point[0] + 1}:{node.start_point[1] + 1}-{node.end_point[0] + 1}:{node.end_point[1] + 1}"
        }
        
        # Only include text for leaf nodes or important node types
        if len(node.children) == 0 or node.type in ["identifier", "string", "number", "comment"]:
            result["text"] = self.tree_sitter_manager.get_node_text(node, source_code)
        
        # Include children if any
        if len(node.children) > 0:
            result["children"] = [
                self._node_to_simplified_dict(child, source_code) for child in node.children
            ]
        
        return result
    
    def _generate_text_visualization(self, node: Any, source_code: bytes, indent: int = 0) -> str:
        """Generate a text visualization of the AST.
        
        Args:
            node: Tree-sitter node
            source_code: Source code as bytes
            indent: Current indentation level
            
        Returns:
            Text visualization of the AST
        """
        node_text = self.tree_sitter_manager.get_node_text(node, source_code)
        # Truncate and escape node text for display
        if len(node_text) > 40:
            display_text = node_text[:37] + "..."
        else:
            display_text = node_text
        
        display_text = display_text.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t")
        
        # Create current node text
        result = "  " * indent + f"{node.type}"
        if node.type in ["identifier", "string", "number", "comment"]:
            result += f" [{display_text}]"
        result += f" ({node.start_point[0] + 1}:{node.start_point[1] + 1})"
        result += "\n"
        
        # Add children
        for child in node.children:
            result += self._generate_text_visualization(child, source_code, indent + 1)
        
        return result
    
    def _generate_html_visualization(self, node: Any, source_code: bytes, file_path: str) -> str:
        """Generate an HTML visualization of the AST.
        
        Args:
            node: Tree-sitter node
            source_code: Source code as bytes
            file_path: Path to the file
            
        Returns:
            HTML visualization of the AST
        """
        # Convert AST to JSON for JavaScript rendering
        ast_dict = self._node_to_dict(node, source_code)
        ast_json = json.dumps(ast_dict)
        
        # Get source code as text
        try:
            source_text = source_code.decode("utf-8")
        except UnicodeDecodeError:
            source_text = "Binary content - cannot display"
        
        # Create HTML with expandable tree view
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>AST Visualization - {os.path.basename(file_path)}</title>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    margin: 0;
                    padding: 0;
                    display: flex;
                    height: 100vh;
                }}
                #ast-container {{
                    flex: 1;
                    overflow: auto;
                    padding: 20px;
                    background-color: #f9f9f9;
                }}
                #source-container {{
                    flex: 1;
                    overflow: auto;
                    padding: 20px;
                    background-color: #f5f5f5;
                    border-left: 1px solid #ccc;
                }}
                pre {{
                    margin: 0;
                    white-space: pre-wrap;
                }}
                .tree-node {{
                    margin-left: 20px;
                }}
                .node-type {{
                    cursor: pointer;
                    font-weight: bold;
                }}
                .node-text {{
                    color: #666;
                    font-family: monospace;
                }}
                .node-location {{
                    color: #999;
                    font-size: 0.8em;
                }}
                .collapsed {{
                    display: none;
                }}
                .node-highlight {{
                    background-color: #ffeb3b;
                }}
            </style>
        </head>
        <body>
            <div id="ast-container">
                <h3>Abstract Syntax Tree - {os.path.basename(file_path)}</h3>
                <div id="ast-tree"></div>
            </div>
            <div id="source-container">
                <h3>Source Code</h3>
                <pre id="source-code">{source_text}</pre>
            </div>
            
            <script>
                // AST data
                const ast = {ast_json};
                
                // Render tree
                function renderTree(node, container) {{
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'tree-node';
                    
                    const nodeHeader = document.createElement('div');
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'node-type';
                    typeSpan.textContent = node.type;
                    typeSpan.onclick = () => {{
                        const children = nodeDiv.querySelector('.node-children');
                        if (children) {{
                            children.classList.toggle('collapsed');
                        }}
                    }};
                    
                    nodeHeader.appendChild(typeSpan);
                    
                    if (node.text && ['identifier', 'string', 'number', 'comment'].includes(node.type)) {{
                        const textSpan = document.createElement('span');
                        textSpan.className = 'node-text';
                        let displayText = node.text;
                        if (displayText.length > 40) {{
                            displayText = displayText.substring(0, 37) + '...';
                        }}
                        displayText = displayText.replace(/\\n/g, '\\\\n')
                                               .replace(/\\r/g, '\\\\r')
                                               .replace(/\\t/g, '\\\\t');
                        textSpan.textContent = ` [${{displayText}}]`;
                        nodeHeader.appendChild(textSpan);
                    }}
                    
                    const locationSpan = document.createElement('span');
                    locationSpan.className = 'node-location';
                    locationSpan.textContent = ` (${{node.start_point.row}}:${{node.start_point.column}})`;
                    locationSpan.onclick = () => {{
                        highlightSourceCode(node.start_point.row, node.end_point.row);
                    }};
                    nodeHeader.appendChild(locationSpan);
                    
                    nodeDiv.appendChild(nodeHeader);
                    
                    if (node.children && node.children.length > 0) {{
                        const childrenDiv = document.createElement('div');
                        childrenDiv.className = 'node-children';
                        
                        for (const child of node.children) {{
                            renderTree(child, childrenDiv);
                        }}
                        
                        nodeDiv.appendChild(childrenDiv);
                    }}
                    
                    container.appendChild(nodeDiv);
                }}
                
                // Highlight source code
                function highlightSourceCode(startRow, endRow) {{
                    const sourceCode = document.getElementById('source-code');
                    const lines = sourceCode.textContent.split('\\n');
                    
                    // Reset highlighting
                    sourceCode.innerHTML = '';
                    
                    for (let i = 0; i < lines.length; i++) {{
                        const lineDiv = document.createElement('div');
                        lineDiv.textContent = lines[i];
                        
                        // Add line number as data attribute
                        lineDiv.dataset.line = i + 1;
                        
                        // Highlight if in range
                        if (i + 1 >= startRow && i + 1 <= endRow) {{
                            lineDiv.className = 'node-highlight';
                        }}
                        
                        sourceCode.appendChild(lineDiv);
                    }}
                    
                    // Scroll to view
                    const firstHighlighted = sourceCode.querySelector('.node-highlight');
                    if (firstHighlighted) {{
                        firstHighlighted.scrollIntoView({{
                            behavior: 'smooth',
                            block: 'center'
                        }});
                    }}
                }}
                
                // Initialize
                window.onload = () => {{
                    const container = document.getElementById('ast-tree');
                    renderTree(ast, container);
                }};
            </script>
        </body>
        </html>
        """
        
        return html
    
    def _extract_python_structure(self, tree: Any, source_code: bytes) -> Dict[str, Any]:
        """Extract Python-specific structure from AST.
        
        Args:
            tree: Parsed tree
            source_code: Source code as bytes
            
        Returns:
            Dictionary with Python structure
        """
        # Define query for Python structure
        query_string = """
            (module) @module
            
            (import_statement
                name: (dotted_name) @import_name) @import
            
            (import_from_statement
                module_name: (dotted_name) @from_module
                name: (dotted_name) @import_item) @import_from
            
            (function_definition
                name: (identifier) @function_name
                parameters: (parameters) @function_params
                body: (block) @function_body) @function
            
            (class_definition
                name: (identifier) @class_name
                body: (block) @class_body) @class
            
            (assignment
                left: (identifier) @variable_name
                right: (_) @variable_value) @variable
        """
        
        # Execute query
        language_name = "python"
        matches = self.tree_sitter_manager.execute_query(language_name, query_string, source_code)
        
        # Process results
        imports = []
        functions = []
        classes = []
        variables = []
        
        for match in matches:
            if "import" in match:
                if "import_name" in match:
                    imports.append({
                        "type": "import",
                        "name": match["import_name"]["text"]
                    })
            elif "import_from" in match:
                if "from_module" in match and "import_item" in match:
                    imports.append({
                        "type": "import_from",
                        "module": match["from_module"]["text"],
                        "name": match["import_item"]["text"]
                    })
            elif "function" in match:
                if "function_name" in match:
                    function_info = {
                        "type": "function",
                        "name": match["function_name"]["text"],
                        "location": match["function_name"]["location"]
                    }
                    functions.append(function_info)
            elif "class" in match:
                if "class_name" in match:
                    class_info = {
                        "type": "class",
                        "name": match["class_name"]["text"],
                        "location": match["class_name"]["location"]
                    }
                    classes.append(class_info)
            elif "variable" in match:
                if "variable_name" in match:
                    variable_info = {
                        "type": "variable",
                        "name": match["variable_name"]["text"],
                        "location": match["variable_name"]["location"]
                    }
                    variables.append(variable_info)
        
        return {
            "language": "python",
            "imports": imports,
            "functions": functions,
            "classes": classes,
            "variables": variables
        }
    
    def _extract_js_ts_structure(self, tree: Any, source_code: bytes, language_name: str) -> Dict[str, Any]:
        """Extract JavaScript/TypeScript-specific structure from AST.
        
        Args:
            tree: Parsed tree
            source_code: Source code as bytes
            language_name: Language name
            
        Returns:
            Dictionary with JS/TS structure
        """
        # Define query for JS/TS structure
        query_string = """
            (program) @program
            
            (import_statement
                source: (string) @import_source) @import
            
            (function_declaration
                name: (identifier) @function_name
                parameters: (formal_parameters) @function_params
                body: (statement_block) @function_body) @function
            
            (class_declaration
                name: (identifier) @class_name
                body: (class_body) @class_body) @class
            
            (method_definition
                name: (property_identifier) @method_name
                parameters: (formal_parameters) @method_params
                body: (statement_block) @method_body) @method
            
            (variable_declaration
                (variable_declarator
                    name: (identifier) @variable_name
                    value: (_) @variable_value)) @variable
        """
        
        # Execute query
        matches = self.tree_sitter_manager.execute_query(language_name, query_string, source_code)
        
        # Process results
        imports = []
        functions = []
        classes = []
        methods = []
        variables = []
        
        for match in matches:
            if "import" in match:
                if "import_source" in match:
                    imports.append({
                        "type": "import",
                        "source": match["import_source"]["text"].strip('\'"')
                    })
            elif "function" in match:
                if "function_name" in match:
                    function_info = {
                        "type": "function",
                        "name": match["function_name"]["text"],
                        "location": match["function_name"]["location"]
                    }
                    functions.append(function_info)
            elif "class" in match:
                if "class_name" in match:
                    class_info = {
                        "type": "class",
                        "name": match["class_name"]["text"],
                        "location": match["class_name"]["location"]
                    }
                    classes.append(class_info)
            elif "method" in match:
                if "method_name" in match:
                    method_info = {
                        "type": "method",
                        "name": match["method_name"]["text"],
                        "location": match["method_name"]["location"]
                    }
                    methods.append(method_info)
            elif "variable" in match:
                if "variable_name" in match:
                    variable_info = {
                        "type": "variable",
                        "name": match["variable_name"]["text"],
                        "location": match["variable_name"]["location"]
                    }
                    variables.append(variable_info)
        
        return {
            "language": language_name,
            "imports": imports,
            "functions": functions,
            "classes": classes,
            "methods": methods,
            "variables": variables
        }
    
    def _extract_c_family_structure(self, tree: Any, source_code: bytes, language_name: str) -> Dict[str, Any]:
        """Extract C-family language structure from AST.
        
        Args:
            tree: Parsed tree
            source_code: Source code as bytes
            language_name: Language name
            
        Returns:
            Dictionary with C-family structure
        """
        # Define query for C-family structure (C, C++, Java, C#)
        query_string = """
            (translation_unit) @unit
            
            (preproc_include
                path: (string_literal) @include_path) @include
            
            (function_definition
                declarator: (function_declarator
                    declarator: (identifier) @function_name)) @function
            
            (declaration
                type: (primitive_type) @variable_type
                declarator: (identifier) @variable_name) @variable
            
            (struct_specifier
                name: (identifier) @struct_name) @struct
            
            (class_specifier
                name: (identifier) @class_name) @class
            
            (namespace_definition
                name: (identifier) @namespace_name) @namespace
        """
        
        # Execute query
        matches = self.tree_sitter_manager.execute_query(language_name, query_string, source_code)
        
        # Process results
        includes = []
        functions = []
        classes = []
        structs = []
        variables = []
        namespaces = []
        
        for match in matches:
            if "include" in match:
                if "include_path" in match:
                    includes.append({
                        "type": "include",
                        "path": match["include_path"]["text"].strip('\'"<>')
                    })
            elif "function" in match:
                if "function_name" in match:
                    function_info = {
                        "type": "function",
                        "name": match["function_name"]["text"],
                        "location": match["function_name"]["location"]
                    }
                    functions.append(function_info)
            elif "class" in match:
                if "class_name" in match:
                    class_info = {
                        "type": "class",
                        "name": match["class_name"]["text"],
                        "location": match["class_name"]["location"]
                    }
                    classes.append(class_info)
            elif "struct" in match:
                if "struct_name" in match:
                    struct_info = {
                        "type": "struct",
                        "name": match["struct_name"]["text"],
                        "location": match["struct_name"]["location"]
                    }
                    structs.append(struct_info)
            elif "variable" in match:
                if "variable_name" in match:
                    variable_info = {
                        "type": "variable",
                        "name": match["variable_name"]["text"],
                        "location": match["variable_name"]["location"]
                    }
                    if "variable_type" in match:
                        variable_info["type_name"] = match["variable_type"]["text"]
                    variables.append(variable_info)
            elif "namespace" in match:
                if "namespace_name" in match:
                    namespace_info = {
                        "type": "namespace",
                        "name": match["namespace_name"]["text"],
                        "location": match["namespace_name"]["location"]
                    }
                    namespaces.append(namespace_info)
        
        return {
            "language": language_name,
            "includes": includes,
            "functions": functions,
            "classes": classes,
            "structs": structs,
            "variables": variables,
            "namespaces": namespaces
        }
    
    def _extract_generic_structure(self, tree: Any, source_code: bytes) -> Dict[str, Any]:
        """Extract generic structure from AST when language-specific extraction is not available.
        
        Args:
            tree: Parsed tree
            source_code: Source code as bytes
            
        Returns:
            Dictionary with generic structure
        """
        # Get all identifiers as a simple approach
        identifier_nodes = self.tree_sitter_manager.find_all_nodes_of_type(tree, "identifier")
        
        identifiers = []
        for node in identifier_nodes:
            identifier_text = self.tree_sitter_manager.get_node_text(node, source_code)
            identifiers.append({
                "name": identifier_text,
                "location": self.tree_sitter_manager.get_node_location(node)
            })
        
        # Get node counts by type
        node_types = {}
        
        def count_node_types(node):
            node_type = node.type
            node_types[node_type] = node_types.get(node_type, 0) + 1
            
            for child in node.children:
                count_node_types(child)
        
        count_node_types(tree.root_node)
        
        return {
            "language": "generic",
            "identifiers": identifiers,
            "node_type_counts": node_types,
            "root_node_type": tree.root_node.type,
            "total_nodes": sum(node_types.values())
        }
